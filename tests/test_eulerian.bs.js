// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/list.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Format from "rescript/lib/es6/format.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as Pack$RescriptOcamlgraph from "../src/pack.bs.js";

function print_vertex(fmt, v) {
  return Curry._1(Format.fprintf(fmt, /* Format */{
                  _0: {
                    TAG: /* Int */4,
                    _0: /* Int_d */0,
                    _1: /* No_padding */0,
                    _2: /* No_precision */0,
                    _3: /* End_of_format */0
                  },
                  _1: "%d"
                }), Curry._1(Pack$RescriptOcamlgraph.Graph.V.label, v));
}

function print_edge(fmt, e) {
  return Curry._4(Format.fprintf(fmt, /* Format */{
                  _0: {
                    TAG: /* Alpha */15,
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "->",
                      _1: {
                        TAG: /* Alpha */15,
                        _0: /* End_of_format */0
                      }
                    }
                  },
                  _1: "%a->%a"
                }), print_vertex, Curry._1(Pack$RescriptOcamlgraph.Graph.E.src, e), print_vertex, Curry._1(Pack$RescriptOcamlgraph.Graph.E.dst, e));
}

function print_path(fmt, p) {
  return List.iter((function (e) {
                return Curry._2(Format.fprintf(fmt, /* Format */{
                                _0: {
                                  TAG: /* Alpha */15,
                                  _0: {
                                    TAG: /* Char_literal */12,
                                    _0: /* ' ' */32,
                                    _1: /* End_of_format */0
                                  }
                                },
                                _1: "%a "
                              }), print_edge, e);
              }), p);
}

function exists_path(g) {
  try {
    Curry._1(Pack$RescriptOcamlgraph.Graph.Eulerian.path, g);
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Invalid_argument") {
      return false;
    }
    throw exn;
  }
}

function exists_cycle(g) {
  try {
    Curry._1(Pack$RescriptOcamlgraph.Graph.Eulerian.cycle, g);
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Invalid_argument") {
      return false;
    }
    throw exn;
  }
}

var g = Curry._2(Pack$RescriptOcamlgraph.Graph.create, undefined, undefined);

function add_vertex(i) {
  var v = Curry._1(Pack$RescriptOcamlgraph.Graph.V.create, i);
  Curry._2(Pack$RescriptOcamlgraph.Graph.add_vertex, g, v);
  return v;
}

function path_length(g) {
  var match = Curry._1(Pack$RescriptOcamlgraph.Graph.Eulerian.path, g);
  return List.length(match[0]);
}

var v0 = add_vertex(0);

if (!exists_path(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          26,
          9
        ],
        Error: new Error()
      };
}

if (!exists_cycle(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          27,
          9
        ],
        Error: new Error()
      };
}

var v1 = add_vertex(1);

if (!exists_path(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          30,
          9
        ],
        Error: new Error()
      };
}

if (!exists_cycle(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          31,
          9
        ],
        Error: new Error()
      };
}

Curry._3(Pack$RescriptOcamlgraph.Graph.add_edge, g, v0, v1);

if (!exists_path(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          34,
          9
        ],
        Error: new Error()
      };
}

if (exists_cycle(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          35,
          9
        ],
        Error: new Error()
      };
}

if (path_length(g) !== 1) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          36,
          9
        ],
        Error: new Error()
      };
}

var v2 = add_vertex(2);

Curry._3(Pack$RescriptOcamlgraph.Graph.add_edge, g, v1, v2);

if (!exists_path(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          40,
          9
        ],
        Error: new Error()
      };
}

if (exists_cycle(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          41,
          9
        ],
        Error: new Error()
      };
}

if (path_length(g) !== 2) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          42,
          9
        ],
        Error: new Error()
      };
}

Curry._3(Pack$RescriptOcamlgraph.Graph.add_edge, g, v2, v0);

if (!exists_path(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          45,
          9
        ],
        Error: new Error()
      };
}

if (!exists_cycle(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          46,
          9
        ],
        Error: new Error()
      };
}

if (path_length(g) !== 3) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          47,
          9
        ],
        Error: new Error()
      };
}

Curry._3(Pack$RescriptOcamlgraph.Graph.add_edge, g, v0, v0);

if (!exists_cycle(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          50,
          9
        ],
        Error: new Error()
      };
}

var v3 = add_vertex(3);

Curry._3(Pack$RescriptOcamlgraph.Graph.add_edge, g, v2, v3);

if (!exists_path(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          54,
          9
        ],
        Error: new Error()
      };
}

if (exists_cycle(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          55,
          9
        ],
        Error: new Error()
      };
}

if (path_length(g) !== 5) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          56,
          9
        ],
        Error: new Error()
      };
}

var v4 = add_vertex(4);

Curry._3(Pack$RescriptOcamlgraph.Graph.add_edge, g, v3, v4);

Curry._3(Pack$RescriptOcamlgraph.Graph.add_edge, g, v2, v4);

if (!exists_cycle(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          61,
          9
        ],
        Error: new Error()
      };
}

if (path_length(g) !== 7) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          62,
          9
        ],
        Error: new Error()
      };
}

Curry._3(Pack$RescriptOcamlgraph.Graph.remove_edge, g, v2, v4);

var v5 = add_vertex(5);

Curry._3(Pack$RescriptOcamlgraph.Graph.add_edge, g, v4, v5);

Curry._3(Pack$RescriptOcamlgraph.Graph.add_edge, g, v5, v3);

if (!exists_path(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          68,
          9
        ],
        Error: new Error()
      };
}

if (exists_cycle(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          69,
          9
        ],
        Error: new Error()
      };
}

if (path_length(g) !== 8) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          70,
          9
        ],
        Error: new Error()
      };
}

Curry._3(Pack$RescriptOcamlgraph.Graph.remove_edge, g, v2, v3);

if (exists_path(g)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          73,
          9
        ],
        Error: new Error()
      };
}

for(var n = 2; n <= 5; ++n){
  var g$1 = Curry._2(Pack$RescriptOcamlgraph.Graph.Classic.full, false, (n << 1));
  if (exists_path(g$1)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "test_eulerian.ml",
            78,
            4
          ],
          Error: new Error()
        };
  }
  var g$2 = Curry._2(Pack$RescriptOcamlgraph.Graph.Classic.full, true, (n << 1));
  if (exists_path(g$2)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "test_eulerian.ml",
            80,
            4
          ],
          Error: new Error()
        };
  }
  var g$3 = Curry._2(Pack$RescriptOcamlgraph.Graph.Classic.full, false, (n << 1) + 1 | 0);
  var match = Curry._1(Pack$RescriptOcamlgraph.Graph.Eulerian.path, g$3);
  if (!match[1]) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "test_eulerian.ml",
            83,
            4
          ],
          Error: new Error()
        };
  }
  if (List.length(match[0]) !== Math.imul(n, (n << 1) + 1 | 0)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "test_eulerian.ml",
            84,
            4
          ],
          Error: new Error()
        };
  }
  var g$4 = Curry._2(Pack$RescriptOcamlgraph.Graph.Classic.full, true, (n << 1) + 1 | 0);
  var match$1 = Curry._1(Pack$RescriptOcamlgraph.Graph.Eulerian.path, g$4);
  if (!match$1[1]) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "test_eulerian.ml",
            87,
            4
          ],
          Error: new Error()
        };
  }
  if (List.length(match$1[0]) !== Math.imul(n + 1 | 0, (n << 1) + 1 | 0)) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "test_eulerian.ml",
            88,
            4
          ],
          Error: new Error()
        };
  }
  
}

var match$2 = Curry._2(Pack$RescriptOcamlgraph.Graph.Classic.grid, 2, 3);

var match$3 = Curry._1(Pack$RescriptOcamlgraph.Graph.Eulerian.path, match$2[0]);

if (match$3[1]) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          97,
          2
        ],
        Error: new Error()
      };
}

if (List.length(match$3[0]) !== 7) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          98,
          2
        ],
        Error: new Error()
      };
}

function exists_path$1(g) {
  try {
    Curry._1(Pack$RescriptOcamlgraph.Digraph.Eulerian.path, g);
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Invalid_argument") {
      return false;
    }
    throw exn;
  }
}

function exists_cycle$1(g) {
  try {
    Curry._1(Pack$RescriptOcamlgraph.Digraph.Eulerian.cycle, g);
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Invalid_argument") {
      return false;
    }
    throw exn;
  }
}

for(var n$1 = 0; n$1 <= 4; ++n$1){
  var match$4 = Curry._1(Pack$RescriptOcamlgraph.Digraph.Classic.cycle, n$1);
  var v = match$4[1];
  var g$5 = match$4[0];
  var match$5 = Curry._1(Pack$RescriptOcamlgraph.Digraph.Eulerian.path, g$5);
  if (!match$5[1]) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "test_eulerian.ml",
            111,
            4
          ],
          Error: new Error()
        };
  }
  if (List.length(match$5[0]) !== n$1) {
    throw {
          RE_EXN_ID: "Assert_failure",
          _1: [
            "test_eulerian.ml",
            112,
            4
          ],
          Error: new Error()
        };
  }
  if (n$1 > 1) {
    Curry._3(Pack$RescriptOcamlgraph.Digraph.remove_edge, g$5, Caml_array.get(v, 0), Caml_array.get(v, 1));
    var match$6 = Curry._1(Pack$RescriptOcamlgraph.Digraph.Eulerian.path, g$5);
    if (match$6[1]) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "test_eulerian.ml",
              116,
              6
            ],
            Error: new Error()
          };
    }
    if (List.length(match$6[0]) !== (n$1 - 1 | 0)) {
      throw {
            RE_EXN_ID: "Assert_failure",
            _1: [
              "test_eulerian.ml",
              117,
              6
            ],
            Error: new Error()
          };
    }
    
  }
  
}

var match$7 = Curry._1(Pack$RescriptOcamlgraph.Digraph.Classic.cycle, 5);

var v$1 = match$7[1];

var g$6 = match$7[0];

Curry._3(Pack$RescriptOcamlgraph.Digraph.add_edge, g$6, Caml_array.get(v$1, 1), Caml_array.get(v$1, 4));

if (exists_cycle$1(g$6)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          123,
          9
        ],
        Error: new Error()
      };
}

if (!exists_path$1(g$6)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          124,
          9
        ],
        Error: new Error()
      };
}

Curry._3(Pack$RescriptOcamlgraph.Digraph.add_edge, g$6, Caml_array.get(v$1, 4), Caml_array.get(v$1, 1));

if (!exists_cycle$1(g$6)) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          126,
          9
        ],
        Error: new Error()
      };
}

var match$8 = Curry._1(Pack$RescriptOcamlgraph.Digraph.Classic.cycle, 3);

var v$2 = match$8[1];

var g$7 = match$8[0];

var v3$1 = Curry._1(Pack$RescriptOcamlgraph.Digraph.V.create, 3);

Curry._2(Pack$RescriptOcamlgraph.Digraph.add_vertex, g$7, v3$1);

Curry._3(Pack$RescriptOcamlgraph.Digraph.add_edge, g$7, Caml_array.get(v$2, 1), v3$1);

Curry._3(Pack$RescriptOcamlgraph.Digraph.add_edge, g$7, v3$1, Caml_array.get(v$2, 0));

var match$9 = Curry._1(Pack$RescriptOcamlgraph.Digraph.Eulerian.path, g$7);

var c = match$9[1];

if (c) {
  throw {
        RE_EXN_ID: "Assert_failure",
        _1: [
          "test_eulerian.ml",
          138,
          9
        ],
        Error: new Error()
      };
}

var G;

export {
  print_vertex ,
  print_edge ,
  print_path ,
  G ,
  add_vertex ,
  path_length ,
  v0 ,
  v1 ,
  v2 ,
  v4 ,
  v5 ,
  exists_path$1 as exists_path,
  exists_cycle$1 as exists_cycle,
  g$7 as g,
  v$2 as v,
  v3$1 as v3,
  c ,
  
}
/* g Not a pure module */
