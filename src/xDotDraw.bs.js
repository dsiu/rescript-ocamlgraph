// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/list.js";
import * as $$Array from "rescript/lib/es6/array.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Scanf from "rescript/lib/es6/scanf.js";
import * as $$Buffer from "rescript/lib/es6/buffer.js";
import * as Printf from "rescript/lib/es6/printf.js";
import * as $$String from "rescript/lib/es6/string.js";
import * as Caml_format from "rescript/lib/es6/caml_format.js";
import * as Caml_string from "rescript/lib/es6/caml_string.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function suffix(s, i) {
  try {
    return $$String.sub(s, i, s.length - i | 0);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === "Invalid_argument") {
      return "";
    }
    throw exn;
  }
}

function split(c, s) {
  var split_from = function (n) {
    try {
      var p = $$String.index_from(s, n, c);
      return {
              hd: $$String.sub(s, n, p - n | 0),
              tl: split_from(p + 1 | 0)
            };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Not_found") {
        return {
                hd: suffix(s, n),
                tl: /* [] */0
              };
      }
      throw exn;
    }
  };
  if (s === "") {
    return /* [] */0;
  } else {
    return split_from(0);
  }
}

function string_scale_size(fontMeasure, font, size, s) {
  var match = Curry._3(fontMeasure, font, size | 0, s);
  var width = match[0];
  var linear_width = size * s.length;
  return [
          size * width / linear_width,
          match[1]
        ];
}

function normalize_color(s) {
  try {
    var match = Curry._1(Scanf.sscanf(s, /* Format */{
              _0: {
                TAG: /* Float */8,
                _0: /* Float_f */0,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* ' ' */32,
                  _1: {
                    TAG: /* Float */8,
                    _0: /* Float_f */0,
                    _1: /* No_padding */0,
                    _2: /* No_precision */0,
                    _3: {
                      TAG: /* Char_literal */12,
                      _0: /* ' ' */32,
                      _1: {
                        TAG: /* Float */8,
                        _0: /* Float_f */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: /* End_of_format */0
                      }
                    }
                  }
                }
              },
              _1: "%f %f %f"
            }), (function (a, b, c) {
            return [
                    a,
                    b,
                    c
                  ];
          }));
    var v = match[2];
    var s$1 = match[1];
    var h$p = 360 * match[0] / 60;
    var hi = (h$p | 0) % 6;
    var f = h$p - Math.floor(h$p);
    var p = v * (1 - s$1);
    var q = v * (1 - f * s$1);
    var t = v * (1 - (1 - f) * s$1);
    var match$1;
    switch (hi) {
      case 0 :
          match$1 = [
            v,
            t,
            p
          ];
          break;
      case 1 :
          match$1 = [
            q,
            v,
            p
          ];
          break;
      case 2 :
          match$1 = [
            p,
            v,
            t
          ];
          break;
      case 3 :
          match$1 = [
            p,
            q,
            v
          ];
          break;
      case 4 :
          match$1 = [
            t,
            p,
            v
          ];
          break;
      case 5 :
          match$1 = [
            v,
            p,
            q
          ];
          break;
      default:
        match$1 = [
          1,
          1,
          1
        ];
    }
    var to_hex = function (x) {
      return Curry._1(Printf.sprintf(/* Format */{
                      _0: {
                        TAG: /* Int */4,
                        _0: /* Int_X */8,
                        _1: {
                          TAG: /* Lit_padding */0,
                          _0: /* Zeros */2,
                          _1: 2
                        },
                        _2: /* No_precision */0,
                        _3: /* End_of_format */0
                      },
                      _1: "%02X"
                    }), x * 255 | 0);
    };
    return "#" + (to_hex(match$1[0]) + (to_hex(match$1[1]) + to_hex(match$1[2])));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Scanf.Scan_failure) {
      return s;
    }
    throw exn;
  }
}

var ParseError = /* @__PURE__ */Caml_exceptions.create("XDotDraw-Graph.ParseError");

var NoOperationId = /* @__PURE__ */Caml_exceptions.create("XDotDraw-Graph.NoOperationId");

function $$char(state) {
  return Caml_string.get(state.str, state.cur);
}

function incr(state) {
  state.cur = state.cur + 1 | 0;
  
}

function over(state) {
  return state.cur >= state.str.length;
}

function is_space(param) {
  if (param >= 11) {
    return param === 32;
  } else {
    return param >= 9;
  }
}

function is_token(param) {
  switch (param) {
    case "B" :
    case "C" :
    case "E" :
    case "F" :
    case "L" :
    case "P" :
    case "S" :
    case "T" :
    case "b" :
    case "c" :
    case "e" :
    case "p" :
        return true;
    default:
      return false;
  }
}

function skip_spaces(state) {
  var _param;
  while(true) {
    if (over(state)) {
      return ;
    }
    if (!is_space($$char(state))) {
      return ;
    }
    incr(state);
    _param = undefined;
    continue ;
  };
}

function get_word(state) {
  skip_spaces(state);
  var start = state.cur;
  var _param;
  while(true) {
    if (over(state)) {
      if (start === state.str.length) {
        return ;
      } else {
        return $$String.sub(state.str, start, state.cur - start | 0);
      }
    }
    if (is_space($$char(state))) {
      return $$String.sub(state.str, start, state.cur - start | 0);
    }
    incr(state);
    _param = undefined;
    continue ;
  };
}

function get_op_id(state) {
  var tok = get_word(state);
  if (tok !== undefined) {
    if (is_token(tok)) {
      return tok;
    }
    throw {
          RE_EXN_ID: NoOperationId,
          Error: new Error()
        };
  }
  throw {
        RE_EXN_ID: NoOperationId,
        Error: new Error()
      };
}

function get_int(state) {
  var w = get_word(state);
  if (w !== undefined) {
    try {
      return Caml_format.caml_int_of_string(w);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Failure") {
        throw {
              RE_EXN_ID: ParseError,
              _1: "Cannot parse int",
              Error: new Error()
            };
      }
      throw exn;
    }
  } else {
    throw {
          RE_EXN_ID: ParseError,
          _1: "Cannot parse int",
          Error: new Error()
        };
  }
}

function get_float(state) {
  var w = get_word(state);
  if (w !== undefined) {
    try {
      return Caml_format.caml_float_of_string(w);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === "Failure") {
        throw {
              RE_EXN_ID: ParseError,
              _1: "Cannot parse float",
              Error: new Error()
            };
      }
      throw exn;
    }
  } else {
    throw {
          RE_EXN_ID: ParseError,
          _1: "Cannot parse float",
          Error: new Error()
        };
  }
}

function get_pos(state) {
  try {
    var x0 = get_float(state);
    var y0 = get_float(state);
    return [
            x0,
            y0
          ];
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === ParseError) {
      throw {
            RE_EXN_ID: ParseError,
            _1: "Cannot parse point in position",
            Error: new Error()
          };
    }
    throw exn;
  }
}

function get_anchor(state) {
  var i = get_int(state);
  if ((i + 1 >>> 0) > 2) {
    throw {
          RE_EXN_ID: ParseError,
          _1: "Cannot parse anchor",
          Error: new Error()
        };
  }
  return i + 1 | 0;
}

function parse_bytes(st) {
  skip_spaces(st);
  var n = get_int(st);
  skip_spaces(st);
  if ($$char(st) !== /* '-' */45) {
    throw {
          RE_EXN_ID: ParseError,
          _1: "Cannot parse bytes",
          Error: new Error()
        };
  }
  incr(st);
  var s = $$String.sub(st.str, st.cur, n);
  st.cur = st.cur + n | 0;
  return s;
}

function parse_ellipse(constr, state) {
  var pos = get_pos(state);
  var w = get_float(state);
  var h = get_float(state);
  return Curry._1(constr, [
              pos,
              w,
              h
            ]);
}

function invert_y_pos(param) {
  return [
          param[0],
          -param[1]
        ];
}

function parse_points(state) {
  var n = get_int(state);
  return $$Array.init(n, (function (param) {
                return invert_y_pos(get_pos(state));
              }));
}

function parse_operation(state) {
  var operation = function (param) {
    var match = get_op_id(state);
    switch (match) {
      case "B" :
          return {
                  TAG: /* Bspline */5,
                  _0: parse_points(state)
                };
      case "C" :
          return {
                  TAG: /* Fill_color */8,
                  _0: normalize_color(parse_bytes(state))
                };
      case "E" :
          return parse_ellipse((function (param) {
                        return {
                                TAG: /* Filled_ellipse */0,
                                _0: invert_y_pos(param[0]),
                                _1: param[1],
                                _2: param[2]
                              };
                      }), state);
      case "F" :
          var size = get_float(state);
          var font = parse_bytes(state);
          return {
                  TAG: /* Font */10,
                  _0: size,
                  _1: font
                };
      case "L" :
          return {
                  TAG: /* Polyline */4,
                  _0: parse_points(state)
                };
      case "P" :
          return {
                  TAG: /* Filled_polygon */2,
                  _0: parse_points(state)
                };
      case "S" :
          var read = function (s) {
            switch (s) {
              case "bold" :
                  return /* Bold */7;
              case "dashed" :
                  return /* Dashed */4;
              case "diagonals" :
                  return /* Diagonals */2;
              case "dotted" :
                  return /* Dotted */5;
              case "filled" :
                  return /* Filled */0;
              case "invisible" :
                  return /* Invisible */1;
              case "rounded" :
                  return /* Rounded */3;
              case "solid" :
                  return /* Solid */6;
              default:
                return /* StyleString */{
                        _0: s
                      };
            }
          };
          var str = parse_bytes(state);
          return {
                  TAG: /* Style */11,
                  _0: List.map(read, split(/* ',' */44, str))
                };
      case "T" :
          var pos = invert_y_pos(get_pos(state));
          var anchor = get_anchor(state);
          var width = get_float(state);
          var str$1 = parse_bytes(state);
          return {
                  TAG: /* Text */7,
                  _0: pos,
                  _1: anchor,
                  _2: width,
                  _3: str$1
                };
      case "b" :
          return {
                  TAG: /* Filled_bspline */6,
                  _0: parse_points(state)
                };
      case "c" :
          return {
                  TAG: /* Pen_color */9,
                  _0: normalize_color(parse_bytes(state))
                };
      case "e" :
          return parse_ellipse((function (param) {
                        return {
                                TAG: /* Unfilled_ellipse */1,
                                _0: invert_y_pos(param[0]),
                                _1: param[1],
                                _2: param[2]
                              };
                      }), state);
      case "p" :
          return {
                  TAG: /* Unfilled_polygon */3,
                  _0: parse_points(state)
                };
      default:
        throw {
              RE_EXN_ID: ParseError,
              _1: "Cannot parse operation",
              Error: new Error()
            };
    }
  };
  try {
    var i = operation(undefined);
    state.operations = {
      hd: i,
      tl: state.operations
    };
    return ;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === NoOperationId) {
      return ;
    }
    throw exn;
  }
}

function remove_backslashes(s) {
  var buf = $$Buffer.create(30);
  var loop = function (_i) {
    while(true) {
      var i = _i;
      if (i === s.length) {
        return ;
      }
      if (Caml_string.get(s, i) === /* '\\' */92 && i < (s.length - 1 | 0) && Caml_string.get(s, i + 1 | 0) === /* '\n' */10) {
        _i = i + 2 | 0;
        continue ;
      }
      $$Buffer.add_char(buf, Caml_string.get(s, i));
      _i = i + 1 | 0;
      continue ;
    };
  };
  loop(0);
  return $$Buffer.contents(buf);
}

function parse(s) {
  var state = {
    operations: /* [] */0,
    cur: 0,
    str: remove_backslashes(s)
  };
  var loop = function (_param) {
    while(true) {
      parse_operation(state);
      if (over(state)) {
        return state.operations;
      }
      _param = undefined;
      continue ;
    };
  };
  try {
    return List.rev(loop(undefined));
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === NoOperationId) {
      return List.rev(state.operations);
    }
    throw exn;
  }
}

function draw_with(f, operations) {
  var st = {
    fill_color: "#FFFFFF",
    pen_color: "#000000",
    font: [
      0,
      ""
    ],
    style: /* [] */0
  };
  var draw_op = function (op) {
    switch (op.TAG | 0) {
      case /* Fill_color */8 :
          st.fill_color = op._0;
          return Curry._2(f, st, op);
      case /* Pen_color */9 :
          st.pen_color = op._0;
          return Curry._2(f, st, op);
      case /* Font */10 :
          st.font = [
            op._0,
            op._1
          ];
          return Curry._2(f, st, op);
      case /* Style */11 :
          st.style = op._0;
          return Curry._2(f, st, op);
      default:
        return Curry._2(f, st, op);
    }
  };
  return List.iter(draw_op, operations);
}

export {
  string_scale_size ,
  parse ,
  draw_with ,
  normalize_color ,
  
}
/* Scanf Not a pure module */
