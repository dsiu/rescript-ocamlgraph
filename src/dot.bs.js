// Generated by ReScript, PLEASE EDIT WITH CARE

import * as $$Map from "rescript/lib/es6/map.js";
import * as List from "rescript/lib/es6/list.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Lexing from "rescript/lib/es6/lexing.js";
import * as Printf from "rescript/lib/es6/printf.js";
import * as Hashtbl from "rescript/lib/es6/hashtbl.js";
import * as Parsing from "rescript/lib/es6/parsing.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Dot_lexer$Graph from "./dot_lexer.bs.js";
import * as Dot_parser$Graph from "./dot_parser.bs.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function parse_dot_ast(f) {
  var c = Pervasives.open_in(f);
  var lb = Lexing.from_channel(c);
  var dot;
  try {
    dot = Dot_parser$Graph.file(Dot_lexer$Graph.token, lb);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Parsing.Parse_error) {
      var n = Lexing.lexeme_start(lb);
      dot = Pervasives.failwith(Curry._1(Printf.sprintf(/* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Dot.parse: parse error character ",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: /* End_of_format */0
                      }
                    },
                    _1: "Dot.parse: parse error character %d"
                  }), n));
    } else {
      throw exn;
    }
  }
  Pervasives.close_in(c);
  return dot;
}

function Parse(funarg, funarg$1) {
  var compare = Caml_obj.caml_compare;
  var M = $$Map.Make({
        compare: compare
      });
  var empty = M.empty;
  var add = function (param, param$1) {
    return List.fold_left((function (a, param) {
                  return Curry._3(M.add, param[0], param[1], a);
                }), param, param$1);
  };
  var list = function (a) {
    return Curry._3(M.fold, (function (x, v, l) {
                  return {
                          hd: [
                            x,
                            v
                          ],
                          tl: l
                        };
                }), a, /* [] */0);
  };
  var create_graph_and_clusters = function (dot) {
    var def_node_attr = {
      contents: empty
    };
    var node_attr = Hashtbl.create(undefined, 97);
    var def_clust_attr = {
      contents: empty
    };
    var clust_attr = Hashtbl.create(undefined, 97);
    var clust_nodes = Hashtbl.create(undefined, 97);
    var add_node_attr = function (id, al) {
      var l;
      try {
        l = Hashtbl.find(node_attr, id);
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          l = def_node_attr.contents;
        } else {
          throw exn;
        }
      }
      return Hashtbl.replace(node_attr, id, List.fold_left(add, l, al));
    };
    var collect_node_attr = function (cluster_op, stmts) {
      return List.iter((function (al) {
                    switch (al.TAG | 0) {
                      case /* Node_stmt */0 :
                          var id = al._0;
                          add_node_attr(id, al._1);
                          if (cluster_op !== undefined) {
                            var id_cluster = Caml_option.valFromOption(cluster_op);
                            var id_nodes;
                            try {
                              id_nodes = Hashtbl.find(clust_nodes, id_cluster);
                            }
                            catch (raw_exn){
                              var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
                              if (exn.RE_EXN_ID === "Not_found") {
                                id_nodes = /* [] */0;
                              } else {
                                throw exn;
                              }
                            }
                            return Hashtbl.add(clust_nodes, id_cluster, {
                                        hd: id,
                                        tl: id_nodes
                                      });
                          } else {
                            return ;
                          }
                      case /* Edge_stmt */1 :
                          var id$1 = al._0;
                          if (id$1.TAG !== /* NodeId */0) {
                            return ;
                          }
                          add_node_attr(id$1._0, /* [] */0);
                          return List.iter((function (id) {
                                        if (id.TAG === /* NodeId */0) {
                                          return add_node_attr(id._0, /* [] */0);
                                        }
                                        
                                      }), al._1);
                      case /* Attr_graph */2 :
                          if (cluster_op !== undefined) {
                            var id_opt = Caml_option.valFromOption(cluster_op);
                            var al$1 = al._0;
                            if (id_opt === undefined) {
                              return ;
                            }
                            var s = id_opt._0;
                            var l;
                            try {
                              l = Hashtbl.find(clust_attr, s);
                            }
                            catch (raw_exn$1){
                              var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
                              if (exn$1.RE_EXN_ID === "Not_found") {
                                l = def_clust_attr.contents;
                              } else {
                                throw exn$1;
                              }
                            }
                            return Hashtbl.replace(clust_attr, s, List.fold_left(add, l, al$1));
                          } else {
                            return ;
                          }
                      case /* Attr_node */3 :
                          def_node_attr.contents = List.fold_left(add, def_node_attr.contents, al._0);
                          return ;
                      case /* Attr_edge */4 :
                      case /* Equal */5 :
                          return ;
                      case /* Subgraph */6 :
                          var match = al._0;
                          if (match.TAG === /* SubgraphId */0) {
                            return ;
                          } else {
                            return collect_node_attr(Caml_option.some(match._0), match._1);
                          }
                      
                    }
                  }), stmts);
    };
    collect_node_attr(undefined, dot.stmts);
    var def_edge_attr = {
      contents: empty
    };
    var nodes = Hashtbl.create(undefined, 97);
    var node = function (g, id, param) {
      try {
        return [
                g,
                Hashtbl.find(nodes, id)
              ];
      }
      catch (raw_exn){
        var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
        if (exn.RE_EXN_ID === "Not_found") {
          var l;
          try {
            l = Hashtbl.find(node_attr, id);
          }
          catch (raw_exn$1){
            var exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            if (exn$1.RE_EXN_ID === "Not_found") {
              l = empty;
            } else {
              throw exn$1;
            }
          }
          var n = Curry._1(funarg.G.V.create, Curry._2(funarg$1.node, id, {
                    hd: list(l),
                    tl: /* [] */0
                  }));
          Hashtbl.add(nodes, id, n);
          return [
                  Curry._2(funarg.add_vertex, g, n),
                  n
                ];
        }
        throw exn;
      }
    };
    var add_stmts = function (g, stmts) {
      return List.fold_left((function (g, s) {
                    switch (s.TAG | 0) {
                      case /* Node_stmt */0 :
                          return node(g, s._0, s._1)[0];
                      case /* Edge_stmt */1 :
                          var id = s._0;
                          if (id.TAG !== /* NodeId */0) {
                            return g;
                          }
                          var al = List.fold_left(add, def_edge_attr.contents, s._2);
                          var el = Curry._1(funarg$1.edge, {
                                hd: list(al),
                                tl: /* [] */0
                              });
                          var match = node(g, id._0, /* [] */0);
                          return List.fold_left((function (param, m) {
                                          var pvn = param[1];
                                          var g = param[0];
                                          if (m.TAG !== /* NodeId */0) {
                                            return [
                                                    g,
                                                    pvn
                                                  ];
                                          }
                                          var match = node(g, m._0, /* [] */0);
                                          var vm = match[1];
                                          var e = Curry._3(funarg.G.E.create, pvn, el, vm);
                                          return [
                                                  Curry._2(funarg.add_edge_e, match[0], e),
                                                  vm
                                                ];
                                        }), [
                                        match[0],
                                        match[1]
                                      ], s._1)[0];
                      case /* Attr_edge */4 :
                          def_edge_attr.contents = List.fold_left(add, def_edge_attr.contents, s._0);
                          return g;
                      case /* Subgraph */6 :
                          var match$1 = s._0;
                          if (match$1.TAG === /* SubgraphId */0) {
                            return g;
                          } else {
                            return add_stmts(g, match$1._1);
                          }
                      default:
                        return g;
                    }
                  }), g, stmts);
    };
    var graph = add_stmts(Curry._1(funarg.empty, undefined), dot.stmts);
    var h = Hashtbl.create(undefined, 30);
    Hashtbl.iter((function (k, a) {
            return Hashtbl.add(h, k, {
                        hd: list(a),
                        tl: /* [] */0
                      });
          }), clust_attr);
    return [
            graph,
            h
          ];
  };
  var get_graph_bb = function (stmts) {
    var graph_bb = {
      contents: undefined
    };
    var read_attr = function (param) {
      var match = param[0];
      if (match.TAG !== /* Ident */0) {
        return ;
      }
      if (match._0 !== "bb") {
        return ;
      }
      var match$1 = param[1];
      if (match$1 !== undefined && match$1.TAG === /* String */2) {
        graph_bb.contents = match$1._0;
        return ;
      }
      
    };
    var read_stmt = function (attrs) {
      if (attrs.TAG === /* Attr_graph */2) {
        return List.iter((function (param) {
                      return List.iter(read_attr, param);
                    }), attrs._0);
      }
      
    };
    List.iter(read_stmt, stmts);
    return graph_bb.contents;
  };
  var parse_dot_from_chan = function (c) {
    var lb = Lexing.from_channel(c);
    var dot;
    try {
      dot = Dot_parser$Graph.file(Dot_lexer$Graph.token, lb);
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Parsing.Parse_error) {
        var n = Lexing.lexeme_start(lb);
        dot = Pervasives.failwith(Curry._1(Printf.sprintf(/* Format */{
                      _0: {
                        TAG: /* String_literal */11,
                        _0: "Dot.parse: parse error character ",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: /* End_of_format */0
                        }
                      },
                      _1: "Dot.parse: parse error character %d"
                    }), n));
      } else {
        throw exn;
      }
    }
    Pervasives.close_in(c);
    return dot;
  };
  var parse = function (f) {
    return create_graph_and_clusters(parse_dot_from_chan(Pervasives.open_in(f)))[0];
  };
  var parse_bounding_box_and_clusters = function (f) {
    var dot = parse_dot_from_chan(Pervasives.open_in(f));
    var match = create_graph_and_clusters(dot);
    var bounding_box = get_graph_bb(dot.stmts);
    if (bounding_box !== undefined) {
      return [
              match[0],
              bounding_box,
              match[1]
            ];
    } else {
      return Pervasives.failwith("Cannot read bounding box in xdot file");
    }
  };
  return {
          parse: parse,
          parse_bounding_box_and_clusters: parse_bounding_box_and_clusters
        };
}

export {
  parse_dot_ast ,
  Parse ,
  
}
/* Dot_lexer-Graph Not a pure module */
