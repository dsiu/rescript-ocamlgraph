// Generated by ReScript, PLEASE EDIT WITH CARE

import * as List from "rescript/lib/es6/list.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Stack from "rescript/lib/es6/stack.js";
import * as Hashtbl from "rescript/lib/es6/hashtbl.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";

var fold_left = List.fold_left;

function Make(funarg) {
  var $$let = funarg.V;
  var HT = Hashtbl.Make({
        equal: $$let.equal,
        hash: $$let.hash
      });
  var recursive_scc = function (g, root_g) {
    var stack = Stack.create(undefined);
    var dfn = Curry._1(HT.create, 1024);
    var num = {
      contents: 0
    };
    var partition = {
      contents: /* [] */0
    };
    Curry._2(funarg.iter_vertex, (function (v) {
            return Curry._3(HT.add, dfn, v, 0);
          }), g);
    var visit = function (vertex, partition) {
      var head = {
        contents: 0
      };
      var loop = {
        contents: false
      };
      Stack.push(vertex, stack);
      num.contents = num.contents + 1 | 0;
      Curry._3(HT.replace, dfn, vertex, num.contents);
      head.contents = num.contents;
      Curry._3(funarg.iter_succ, (function (succ) {
              var dfn_succ = Curry._2(HT.find, dfn, succ);
              var min = dfn_succ === 0 ? visit(succ, partition) : dfn_succ;
              if (min <= head.contents) {
                head.contents = min;
                loop.contents = true;
                return ;
              }
              
            }), g, vertex);
      if (head.contents === Curry._2(HT.find, dfn, vertex)) {
        Curry._3(HT.replace, dfn, vertex, Pervasives.max_int);
        var element = Stack.pop(stack);
        if (loop.contents) {
          while(Curry._2(funarg.V.compare, element, vertex) !== 0) {
            Curry._3(HT.replace, dfn, element, 0);
            element = Stack.pop(stack);
          };
          partition.contents = {
            hd: component(vertex),
            tl: partition.contents
          };
        } else {
          partition.contents = {
            hd: {
              TAG: /* Vertex */0,
              _0: vertex
            },
            tl: partition.contents
          };
        }
      }
      return head.contents;
    };
    var component = function (vertex) {
      var partition = {
        contents: /* [] */0
      };
      Curry._3(funarg.iter_succ, (function (succ) {
              if (Curry._2(HT.find, dfn, succ) === 0) {
                visit(succ, partition);
                return ;
              }
              
            }), g, vertex);
      return {
              TAG: /* Component */1,
              _0: vertex,
              _1: partition.contents
            };
    };
    visit(root_g, partition);
    return partition.contents;
  };
  return {
          recursive_scc: recursive_scc
        };
}

export {
  fold_left ,
  Make ,
  
}
/* No side effect */
