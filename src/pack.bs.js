// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Caml_sys from "rescript/lib/es6/caml_sys.js";
import * as Filename from "rescript/lib/es6/filename.js";
import * as Flow$Graph from "./flow.bs.js";
import * as Oper$Graph from "./oper.bs.js";
import * as Path$Graph from "./path.bs.js";
import * as Pervasives from "rescript/lib/es6/pervasives.js";
import * as Rand$Graph from "./rand.bs.js";
import * as Builder$Graph from "./builder.bs.js";
import * as Classic$Graph from "./classic.bs.js";
import * as Kruskal$Graph from "./kruskal.bs.js";
import * as Coloring$Graph from "./coloring.bs.js";
import * as Eulerian$Graph from "./eulerian.bs.js";
import * as Graphviz$Graph from "./graphviz.bs.js";
import * as Traverse$Graph from "./traverse.bs.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";
import * as Components$Graph from "./components.bs.js";
import * as Imperative$Graph from "./imperative.bs.js";
import * as Topological$Graph from "./topological.bs.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as Caml_external_polyfill from "rescript/lib/es6/caml_external_polyfill.js";

var compare = Caml.caml_int_compare;

var I = {
  compare: compare,
  $$default: 0
};

var partial_arg = {};

var partial_arg$1 = Imperative$Graph.Digraph.AbstractLabeled;

var G = (function (param) {
      return partial_arg$1(partial_arg, param);
    })(I);

var V = G.V;

var is_directed = G.is_directed;

var iter_vertex = G.iter_vertex;

var Found = /* @__PURE__ */Caml_exceptions.create("Pack-Graph.Generic(G).Found");

function find_vertex(g, i) {
  try {
    Curry._2(iter_vertex, (function (v) {
            if (Curry._1(V.label, v) !== i) {
              return ;
            }
            throw {
                  RE_EXN_ID: Found,
                  _1: v,
                  Error: new Error()
                };
          }), g);
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  catch (raw_v){
    var v = Caml_js_exceptions.internalToOCamlException(raw_v);
    if (v.RE_EXN_ID === Found) {
      return v._1;
    }
    throw v;
  }
}

var Builder = Builder$Graph.I(G);

var Dfs = Traverse$Graph.Dfs({
      is_directed: G.is_directed,
      V: G.V,
      iter_vertex: G.iter_vertex,
      fold_vertex: G.fold_vertex,
      iter_succ: G.iter_succ,
      fold_succ: G.fold_succ
    });

var Bfs = Traverse$Graph.Bfs({
      is_directed: G.is_directed,
      V: G.V,
      iter_vertex: G.iter_vertex,
      fold_vertex: G.fold_vertex,
      iter_succ: G.iter_succ,
      fold_succ: G.fold_succ
    });

var Marking = Traverse$Graph.Mark({
      V: {},
      iter_vertex: G.iter_vertex,
      iter_succ: G.iter_succ,
      Mark: G.Mark
    });

var $$let = G.Mark;

var Coloring = Coloring$Graph.Mark({
      is_directed: G.is_directed,
      nb_vertex: G.nb_vertex,
      V: G.V,
      out_degree: G.out_degree,
      iter_vertex: G.iter_vertex,
      fold_vertex: G.fold_vertex,
      iter_succ: G.iter_succ,
      fold_succ: G.fold_succ,
      Mark: {
        get: $$let.get,
        set: $$let.set
      }
    });

var Classic = Classic$Graph.I(G);

var Rand = Rand$Graph.I(G);

var Components = Components$Graph.Make({
      V: G.V,
      iter_vertex: G.iter_vertex,
      iter_succ: G.iter_succ
    });

function weight(e) {
  return Curry._1(G.E.label, e);
}

function add(prim0, prim1) {
  return prim0 + prim1 | 0;
}

function sub(prim0, prim1) {
  return prim0 - prim1 | 0;
}

var compare$1 = Caml.caml_int_compare;

var $$let$1 = G.E;

var partial_arg_V = G.V;

var partial_arg_E = {
  label: $$let$1.label,
  src: $$let$1.src,
  dst: $$let$1.dst,
  create: $$let$1.create
};

var partial_arg_iter_vertex = G.iter_vertex;

var partial_arg_fold_vertex = G.fold_vertex;

var partial_arg_iter_succ = G.iter_succ;

var partial_arg_iter_succ_e = G.iter_succ_e;

var partial_arg_fold_edges_e = G.fold_edges_e;

var partial_arg_nb_vertex = G.nb_vertex;

var partial_arg$2 = {
  V: partial_arg_V,
  E: partial_arg_E,
  iter_vertex: partial_arg_iter_vertex,
  fold_vertex: partial_arg_fold_vertex,
  iter_succ: partial_arg_iter_succ,
  iter_succ_e: partial_arg_iter_succ_e,
  fold_edges_e: partial_arg_fold_edges_e,
  nb_vertex: partial_arg_nb_vertex
};

var partial_arg$3 = Path$Graph.Dijkstra;

var include = (function (param) {
      return partial_arg$3(partial_arg$2, param);
    })({
      weight: weight,
      compare: compare$1,
      add: add,
      zero: 0
    });

var $$let$2 = G.E;

var partial_arg_V$1 = G.V;

var partial_arg_E$1 = {
  label: $$let$2.label,
  src: $$let$2.src,
  dst: $$let$2.dst,
  create: $$let$2.create
};

var partial_arg_iter_vertex$1 = G.iter_vertex;

var partial_arg_fold_vertex$1 = G.fold_vertex;

var partial_arg_iter_succ$1 = G.iter_succ;

var partial_arg_iter_succ_e$1 = G.iter_succ_e;

var partial_arg_fold_edges_e$1 = G.fold_edges_e;

var partial_arg_nb_vertex$1 = G.nb_vertex;

var partial_arg$4 = {
  V: partial_arg_V$1,
  E: partial_arg_E$1,
  iter_vertex: partial_arg_iter_vertex$1,
  fold_vertex: partial_arg_fold_vertex$1,
  iter_succ: partial_arg_iter_succ$1,
  iter_succ_e: partial_arg_iter_succ_e$1,
  fold_edges_e: partial_arg_fold_edges_e$1,
  nb_vertex: partial_arg_nb_vertex$1
};

var partial_arg$5 = Path$Graph.Johnson;

((function (param) {
        return partial_arg$5(partial_arg$4, param);
      })({
        weight: weight,
        compare: compare$1,
        add: add,
        zero: 0,
        sub: sub
      }));

var $$let$3 = G.E;

var partial_arg_V$2 = G.V;

var partial_arg_E$2 = {
  label: $$let$3.label,
  src: $$let$3.src,
  dst: $$let$3.dst,
  create: $$let$3.create
};

var partial_arg_iter_vertex$2 = G.iter_vertex;

var partial_arg_fold_vertex$2 = G.fold_vertex;

var partial_arg_iter_succ$2 = G.iter_succ;

var partial_arg_iter_succ_e$2 = G.iter_succ_e;

var partial_arg_fold_edges_e$2 = G.fold_edges_e;

var partial_arg_nb_vertex$2 = G.nb_vertex;

var partial_arg$6 = {
  V: partial_arg_V$2,
  E: partial_arg_E$2,
  iter_vertex: partial_arg_iter_vertex$2,
  fold_vertex: partial_arg_fold_vertex$2,
  iter_succ: partial_arg_iter_succ$2,
  iter_succ_e: partial_arg_iter_succ_e$2,
  fold_edges_e: partial_arg_fold_edges_e$2,
  nb_vertex: partial_arg_nb_vertex$2
};

var partial_arg$7 = Path$Graph.BellmanFord;

var BF = (function (param) {
      return partial_arg$7(partial_arg$6, param);
    })({
      weight: weight,
      compare: compare$1,
      add: add,
      zero: 0
    });

function max_capacity(x) {
  return x;
}

function min_capacity(param) {
  return 0;
}

function flow(param) {
  return 0;
}

function add$1(prim0, prim1) {
  return prim0 + prim1 | 0;
}

function sub$1(prim0, prim1) {
  return prim0 - prim1 | 0;
}

var compare$2 = Caml.caml_int_compare;

var $$let$4 = G.V;

var $$let$5 = G.E;

var partial_arg_V$3 = {
  hash: $$let$4.hash,
  equal: $$let$4.equal
};

var partial_arg_E$3 = {
  src: $$let$5.src,
  dst: $$let$5.dst,
  label: $$let$5.label
};

var partial_arg_iter_succ_e$3 = G.iter_succ_e;

var partial_arg_iter_pred_e = G.iter_pred_e;

var partial_arg$8 = {
  V: partial_arg_V$3,
  E: partial_arg_E$3,
  iter_succ_e: partial_arg_iter_succ_e$3,
  iter_pred_e: partial_arg_iter_pred_e
};

var partial_arg$9 = Flow$Graph.Ford_Fulkerson;

var FF = (function (param) {
      return partial_arg$9(partial_arg$8, param);
    })({
      max_capacity: max_capacity,
      flow: flow,
      add: add$1,
      sub: sub$1,
      zero: 0,
      compare: compare$2,
      min_capacity: min_capacity
    });

function ford_fulkerson(g) {
  if (!G.is_directed) {
    Pervasives.invalid_arg("ford_fulkerson: not a directed graph");
  }
  return Curry._1(FF.maxflow, g);
}

var partial_arg_V$4 = G.V;

var partial_arg_E$4 = G.E;

var partial_arg_nb_vertex$3 = G.nb_vertex;

var partial_arg_nb_edges = G.nb_edges;

var partial_arg_fold_edges_e$3 = G.fold_edges_e;

var partial_arg_fold_succ_e = G.fold_succ_e;

var partial_arg_fold_pred_e = G.fold_pred_e;

var partial_arg$10 = {
  V: partial_arg_V$4,
  E: partial_arg_E$4,
  nb_vertex: partial_arg_nb_vertex$3,
  nb_edges: partial_arg_nb_edges,
  fold_edges_e: partial_arg_fold_edges_e$3,
  fold_succ_e: partial_arg_fold_succ_e,
  fold_pred_e: partial_arg_fold_pred_e
};

var partial_arg$11 = Flow$Graph.Goldberg_Tarjan;

var Goldberg = (function (param) {
      return partial_arg$11(partial_arg$10, param);
    })({
      max_capacity: max_capacity,
      flow: flow,
      add: add$1,
      sub: sub$1,
      zero: 0,
      compare: compare$2
    });

function goldberg_tarjan(g) {
  if (!G.is_directed) {
    Pervasives.invalid_arg("goldberg: not a directed graph");
  }
  return Curry._1(Goldberg.maxflow, g);
}

var include$1 = Oper$Graph.Make(Builder);

var PathCheck = Path$Graph.Check({
      V: G.V,
      iter_succ: G.iter_succ
    });

var include$2 = Topological$Graph.Make({
      V: G.V,
      iter_vertex: G.iter_vertex,
      iter_succ: G.iter_succ
    });

var S = Topological$Graph.Make_stable({
      V: G.V,
      iter_vertex: G.iter_vertex,
      iter_succ: G.iter_succ,
      in_degree: G.in_degree
    });

var include$3 = Eulerian$Graph.Make({
      is_directed: G.is_directed,
      V: G.V,
      E: G.E,
      iter_edges_e: G.iter_edges_e
    });

var Eulerian = include$3;

var compare$3 = Caml.caml_int_compare;

var Int = {
  compare: compare$3
};

var $$let$6 = G.E;

var partial_arg_V$5 = G.V;

var partial_arg_E$5 = {
  label: $$let$6.label,
  dst: $$let$6.dst,
  src: $$let$6.src
};

var partial_arg_fold_vertex$3 = G.fold_vertex;

var partial_arg_iter_edges_e = G.iter_edges_e;

var partial_arg$12 = {
  V: partial_arg_V$5,
  E: partial_arg_E$5,
  fold_vertex: partial_arg_fold_vertex$3,
  iter_edges_e: partial_arg_iter_edges_e
};

var partial_arg$13 = Kruskal$Graph.Make;

var include$4 = (function (param) {
      return partial_arg$13(partial_arg$12, param);
    })(Int);

var V$1 = G.V;

var E = G.E;

var iter_vertex$1 = G.iter_vertex;

var iter_edges_e = G.iter_edges_e;

function vertex_name(v) {
  return String(Curry._1(V$1.label, v));
}

function graph_attributes(param) {
  return /* [] */0;
}

function default_vertex_attributes(param) {
  return /* [] */0;
}

function vertex_attributes(param) {
  return /* [] */0;
}

function default_edge_attributes(param) {
  return /* [] */0;
}

function edge_attributes(e) {
  return {
          hd: {
            NAME: "Label",
            VAL: String(Curry._1(E.label, e))
          },
          tl: /* [] */0
        };
}

function get_subgraph(param) {
  
}

var Dot_ = Graphviz$Graph.Dot({
      V: {},
      E: {
        src: E.src,
        dst: E.dst
      },
      iter_vertex: iter_vertex$1,
      iter_edges_e: iter_edges_e,
      graph_attributes: graph_attributes,
      default_vertex_attributes: default_vertex_attributes,
      vertex_name: vertex_name,
      vertex_attributes: vertex_attributes,
      get_subgraph: get_subgraph,
      default_edge_attributes: default_edge_attributes,
      edge_attributes: edge_attributes
    });

var Neato = Graphviz$Graph.Neato({
      V: {},
      E: {
        src: E.src,
        dst: E.dst
      },
      iter_vertex: iter_vertex$1,
      iter_edges_e: iter_edges_e,
      graph_attributes: graph_attributes,
      default_vertex_attributes: default_vertex_attributes,
      vertex_name: vertex_name,
      vertex_attributes: vertex_attributes,
      get_subgraph: get_subgraph,
      default_edge_attributes: default_edge_attributes,
      edge_attributes: edge_attributes
    });

function dot_output(g, f) {
  var oc = Pervasives.open_out(f);
  if (is_directed) {
    Curry._2(Dot_.output_graph, oc, g);
  } else {
    Curry._2(Neato.output_graph, oc, g);
  }
  return Pervasives.close_out(oc);
}

function display_with_gv(g) {
  var tmp = Filename.temp_file(undefined, "graph", ".dot");
  dot_output(g, tmp);
  Caml_sys.caml_sys_system_command("dot -Tps " + (tmp + " | gv -"));
  return Caml_external_polyfill.resolve("caml_sys_remove")(tmp);
}

var partial_arg$14 = {};

var partial_arg$15 = Imperative$Graph.Graph.AbstractLabeled;

var G$1 = (function (param) {
      return partial_arg$15(partial_arg$14, param);
    })(I);

var V$2 = G$1.V;

var is_directed$1 = G$1.is_directed;

var iter_vertex$2 = G$1.iter_vertex;

var Found$1 = /* @__PURE__ */Caml_exceptions.create("Pack-Graph.Generic(G).Found");

function find_vertex$1(g, i) {
  try {
    Curry._2(iter_vertex$2, (function (v) {
            if (Curry._1(V$2.label, v) !== i) {
              return ;
            }
            throw {
                  RE_EXN_ID: Found$1,
                  _1: v,
                  Error: new Error()
                };
          }), g);
    throw {
          RE_EXN_ID: "Not_found",
          Error: new Error()
        };
  }
  catch (raw_v){
    var v = Caml_js_exceptions.internalToOCamlException(raw_v);
    if (v.RE_EXN_ID === Found$1) {
      return v._1;
    }
    throw v;
  }
}

var Builder$1 = Builder$Graph.I(G$1);

var Dfs$1 = Traverse$Graph.Dfs({
      is_directed: G$1.is_directed,
      V: G$1.V,
      iter_vertex: G$1.iter_vertex,
      fold_vertex: G$1.fold_vertex,
      iter_succ: G$1.iter_succ,
      fold_succ: G$1.fold_succ
    });

var Bfs$1 = Traverse$Graph.Bfs({
      is_directed: G$1.is_directed,
      V: G$1.V,
      iter_vertex: G$1.iter_vertex,
      fold_vertex: G$1.fold_vertex,
      iter_succ: G$1.iter_succ,
      fold_succ: G$1.fold_succ
    });

var Marking$1 = Traverse$Graph.Mark({
      V: {},
      iter_vertex: G$1.iter_vertex,
      iter_succ: G$1.iter_succ,
      Mark: G$1.Mark
    });

var $$let$7 = G$1.Mark;

var Coloring$1 = Coloring$Graph.Mark({
      is_directed: G$1.is_directed,
      nb_vertex: G$1.nb_vertex,
      V: G$1.V,
      out_degree: G$1.out_degree,
      iter_vertex: G$1.iter_vertex,
      fold_vertex: G$1.fold_vertex,
      iter_succ: G$1.iter_succ,
      fold_succ: G$1.fold_succ,
      Mark: {
        get: $$let$7.get,
        set: $$let$7.set
      }
    });

var Classic$1 = Classic$Graph.I(G$1);

var Rand$1 = Rand$Graph.I(G$1);

var Components$1 = Components$Graph.Make({
      V: G$1.V,
      iter_vertex: G$1.iter_vertex,
      iter_succ: G$1.iter_succ
    });

function weight$1(e) {
  return Curry._1(G$1.E.label, e);
}

function add$2(prim0, prim1) {
  return prim0 + prim1 | 0;
}

function sub$2(prim0, prim1) {
  return prim0 - prim1 | 0;
}

var compare$4 = Caml.caml_int_compare;

var $$let$8 = G$1.E;

var partial_arg_V$6 = G$1.V;

var partial_arg_E$6 = {
  label: $$let$8.label,
  src: $$let$8.src,
  dst: $$let$8.dst,
  create: $$let$8.create
};

var partial_arg_iter_vertex$3 = G$1.iter_vertex;

var partial_arg_fold_vertex$4 = G$1.fold_vertex;

var partial_arg_iter_succ$3 = G$1.iter_succ;

var partial_arg_iter_succ_e$4 = G$1.iter_succ_e;

var partial_arg_fold_edges_e$4 = G$1.fold_edges_e;

var partial_arg_nb_vertex$4 = G$1.nb_vertex;

var partial_arg$16 = {
  V: partial_arg_V$6,
  E: partial_arg_E$6,
  iter_vertex: partial_arg_iter_vertex$3,
  fold_vertex: partial_arg_fold_vertex$4,
  iter_succ: partial_arg_iter_succ$3,
  iter_succ_e: partial_arg_iter_succ_e$4,
  fold_edges_e: partial_arg_fold_edges_e$4,
  nb_vertex: partial_arg_nb_vertex$4
};

var partial_arg$17 = Path$Graph.Dijkstra;

var include$5 = (function (param) {
      return partial_arg$17(partial_arg$16, param);
    })({
      weight: weight$1,
      compare: compare$4,
      add: add$2,
      zero: 0
    });

var $$let$9 = G$1.E;

var partial_arg_V$7 = G$1.V;

var partial_arg_E$7 = {
  label: $$let$9.label,
  src: $$let$9.src,
  dst: $$let$9.dst,
  create: $$let$9.create
};

var partial_arg_iter_vertex$4 = G$1.iter_vertex;

var partial_arg_fold_vertex$5 = G$1.fold_vertex;

var partial_arg_iter_succ$4 = G$1.iter_succ;

var partial_arg_iter_succ_e$5 = G$1.iter_succ_e;

var partial_arg_fold_edges_e$5 = G$1.fold_edges_e;

var partial_arg_nb_vertex$5 = G$1.nb_vertex;

var partial_arg$18 = {
  V: partial_arg_V$7,
  E: partial_arg_E$7,
  iter_vertex: partial_arg_iter_vertex$4,
  fold_vertex: partial_arg_fold_vertex$5,
  iter_succ: partial_arg_iter_succ$4,
  iter_succ_e: partial_arg_iter_succ_e$5,
  fold_edges_e: partial_arg_fold_edges_e$5,
  nb_vertex: partial_arg_nb_vertex$5
};

var partial_arg$19 = Path$Graph.Johnson;

((function (param) {
        return partial_arg$19(partial_arg$18, param);
      })({
        weight: weight$1,
        compare: compare$4,
        add: add$2,
        zero: 0,
        sub: sub$2
      }));

var $$let$10 = G$1.E;

var partial_arg_V$8 = G$1.V;

var partial_arg_E$8 = {
  label: $$let$10.label,
  src: $$let$10.src,
  dst: $$let$10.dst,
  create: $$let$10.create
};

var partial_arg_iter_vertex$5 = G$1.iter_vertex;

var partial_arg_fold_vertex$6 = G$1.fold_vertex;

var partial_arg_iter_succ$5 = G$1.iter_succ;

var partial_arg_iter_succ_e$6 = G$1.iter_succ_e;

var partial_arg_fold_edges_e$6 = G$1.fold_edges_e;

var partial_arg_nb_vertex$6 = G$1.nb_vertex;

var partial_arg$20 = {
  V: partial_arg_V$8,
  E: partial_arg_E$8,
  iter_vertex: partial_arg_iter_vertex$5,
  fold_vertex: partial_arg_fold_vertex$6,
  iter_succ: partial_arg_iter_succ$5,
  iter_succ_e: partial_arg_iter_succ_e$6,
  fold_edges_e: partial_arg_fold_edges_e$6,
  nb_vertex: partial_arg_nb_vertex$6
};

var partial_arg$21 = Path$Graph.BellmanFord;

var BF$1 = (function (param) {
      return partial_arg$21(partial_arg$20, param);
    })({
      weight: weight$1,
      compare: compare$4,
      add: add$2,
      zero: 0
    });

function max_capacity$1(x) {
  return x;
}

function min_capacity$1(param) {
  return 0;
}

function flow$1(param) {
  return 0;
}

function add$3(prim0, prim1) {
  return prim0 + prim1 | 0;
}

function sub$3(prim0, prim1) {
  return prim0 - prim1 | 0;
}

var compare$5 = Caml.caml_int_compare;

var $$let$11 = G$1.V;

var $$let$12 = G$1.E;

var partial_arg_V$9 = {
  hash: $$let$11.hash,
  equal: $$let$11.equal
};

var partial_arg_E$9 = {
  src: $$let$12.src,
  dst: $$let$12.dst,
  label: $$let$12.label
};

var partial_arg_iter_succ_e$7 = G$1.iter_succ_e;

var partial_arg_iter_pred_e$1 = G$1.iter_pred_e;

var partial_arg$22 = {
  V: partial_arg_V$9,
  E: partial_arg_E$9,
  iter_succ_e: partial_arg_iter_succ_e$7,
  iter_pred_e: partial_arg_iter_pred_e$1
};

var partial_arg$23 = Flow$Graph.Ford_Fulkerson;

var FF$1 = (function (param) {
      return partial_arg$23(partial_arg$22, param);
    })({
      max_capacity: max_capacity$1,
      flow: flow$1,
      add: add$3,
      sub: sub$3,
      zero: 0,
      compare: compare$5,
      min_capacity: min_capacity$1
    });

function ford_fulkerson$1(g) {
  if (!G$1.is_directed) {
    Pervasives.invalid_arg("ford_fulkerson: not a directed graph");
  }
  return Curry._1(FF$1.maxflow, g);
}

var partial_arg_V$10 = G$1.V;

var partial_arg_E$10 = G$1.E;

var partial_arg_nb_vertex$7 = G$1.nb_vertex;

var partial_arg_nb_edges$1 = G$1.nb_edges;

var partial_arg_fold_edges_e$7 = G$1.fold_edges_e;

var partial_arg_fold_succ_e$1 = G$1.fold_succ_e;

var partial_arg_fold_pred_e$1 = G$1.fold_pred_e;

var partial_arg$24 = {
  V: partial_arg_V$10,
  E: partial_arg_E$10,
  nb_vertex: partial_arg_nb_vertex$7,
  nb_edges: partial_arg_nb_edges$1,
  fold_edges_e: partial_arg_fold_edges_e$7,
  fold_succ_e: partial_arg_fold_succ_e$1,
  fold_pred_e: partial_arg_fold_pred_e$1
};

var partial_arg$25 = Flow$Graph.Goldberg_Tarjan;

var Goldberg$1 = (function (param) {
      return partial_arg$25(partial_arg$24, param);
    })({
      max_capacity: max_capacity$1,
      flow: flow$1,
      add: add$3,
      sub: sub$3,
      zero: 0,
      compare: compare$5
    });

function goldberg_tarjan$1(g) {
  if (!G$1.is_directed) {
    Pervasives.invalid_arg("goldberg: not a directed graph");
  }
  return Curry._1(Goldberg$1.maxflow, g);
}

var include$6 = Oper$Graph.Make(Builder$1);

var PathCheck$1 = Path$Graph.Check({
      V: G$1.V,
      iter_succ: G$1.iter_succ
    });

var include$7 = Topological$Graph.Make({
      V: G$1.V,
      iter_vertex: G$1.iter_vertex,
      iter_succ: G$1.iter_succ
    });

var S$1 = Topological$Graph.Make_stable({
      V: G$1.V,
      iter_vertex: G$1.iter_vertex,
      iter_succ: G$1.iter_succ,
      in_degree: G$1.in_degree
    });

var include$8 = Eulerian$Graph.Make({
      is_directed: G$1.is_directed,
      V: G$1.V,
      E: G$1.E,
      iter_edges_e: G$1.iter_edges_e
    });

var Eulerian$1 = include$8;

var compare$6 = Caml.caml_int_compare;

var Int$1 = {
  compare: compare$6
};

var $$let$13 = G$1.E;

var partial_arg_V$11 = G$1.V;

var partial_arg_E$11 = {
  label: $$let$13.label,
  dst: $$let$13.dst,
  src: $$let$13.src
};

var partial_arg_fold_vertex$7 = G$1.fold_vertex;

var partial_arg_iter_edges_e$1 = G$1.iter_edges_e;

var partial_arg$26 = {
  V: partial_arg_V$11,
  E: partial_arg_E$11,
  fold_vertex: partial_arg_fold_vertex$7,
  iter_edges_e: partial_arg_iter_edges_e$1
};

var partial_arg$27 = Kruskal$Graph.Make;

var include$9 = (function (param) {
      return partial_arg$27(partial_arg$26, param);
    })(Int$1);

var V$3 = G$1.V;

var E$1 = G$1.E;

var iter_vertex$3 = G$1.iter_vertex;

var iter_edges_e$1 = G$1.iter_edges_e;

function vertex_name$1(v) {
  return String(Curry._1(V$3.label, v));
}

function graph_attributes$1(param) {
  return /* [] */0;
}

function default_vertex_attributes$1(param) {
  return /* [] */0;
}

function vertex_attributes$1(param) {
  return /* [] */0;
}

function default_edge_attributes$1(param) {
  return /* [] */0;
}

function edge_attributes$1(e) {
  return {
          hd: {
            NAME: "Label",
            VAL: String(Curry._1(E$1.label, e))
          },
          tl: /* [] */0
        };
}

function get_subgraph$1(param) {
  
}

var Dot_$1 = Graphviz$Graph.Dot({
      V: {},
      E: {
        src: E$1.src,
        dst: E$1.dst
      },
      iter_vertex: iter_vertex$3,
      iter_edges_e: iter_edges_e$1,
      graph_attributes: graph_attributes$1,
      default_vertex_attributes: default_vertex_attributes$1,
      vertex_name: vertex_name$1,
      vertex_attributes: vertex_attributes$1,
      get_subgraph: get_subgraph$1,
      default_edge_attributes: default_edge_attributes$1,
      edge_attributes: edge_attributes$1
    });

var Neato$1 = Graphviz$Graph.Neato({
      V: {},
      E: {
        src: E$1.src,
        dst: E$1.dst
      },
      iter_vertex: iter_vertex$3,
      iter_edges_e: iter_edges_e$1,
      graph_attributes: graph_attributes$1,
      default_vertex_attributes: default_vertex_attributes$1,
      vertex_name: vertex_name$1,
      vertex_attributes: vertex_attributes$1,
      get_subgraph: get_subgraph$1,
      default_edge_attributes: default_edge_attributes$1,
      edge_attributes: edge_attributes$1
    });

function dot_output$1(g, f) {
  var oc = Pervasives.open_out(f);
  if (is_directed$1) {
    Curry._2(Dot_$1.output_graph, oc, g);
  } else {
    Curry._2(Neato$1.output_graph, oc, g);
  }
  return Pervasives.close_out(oc);
}

function display_with_gv$1(g) {
  var tmp = Filename.temp_file(undefined, "graph", ".dot");
  dot_output$1(g, tmp);
  Caml_sys.caml_sys_system_command("dot -Tps " + (tmp + " | gv -"));
  return Caml_external_polyfill.resolve("caml_sys_remove")(tmp);
}

var Digraph_E = G.E;

var Digraph_create = G.create;

var Digraph_clear = G.clear;

var Digraph_copy = G.copy;

var Digraph_add_vertex = G.add_vertex;

var Digraph_remove_vertex = G.remove_vertex;

var Digraph_add_edge = G.add_edge;

var Digraph_add_edge_e = G.add_edge_e;

var Digraph_remove_edge = G.remove_edge;

var Digraph_remove_edge_e = G.remove_edge_e;

var Digraph_Mark = G.Mark;

var Digraph_is_empty = G.is_empty;

var Digraph_nb_vertex = G.nb_vertex;

var Digraph_nb_edges = G.nb_edges;

var Digraph_out_degree = G.out_degree;

var Digraph_in_degree = G.in_degree;

var Digraph_mem_vertex = G.mem_vertex;

var Digraph_mem_edge = G.mem_edge;

var Digraph_mem_edge_e = G.mem_edge_e;

var Digraph_find_edge = G.find_edge;

var Digraph_find_all_edges = G.find_all_edges;

var Digraph_succ = G.succ;

var Digraph_pred = G.pred;

var Digraph_succ_e = G.succ_e;

var Digraph_pred_e = G.pred_e;

var Digraph_iter_edges = G.iter_edges;

var Digraph_fold_vertex = G.fold_vertex;

var Digraph_fold_edges = G.fold_edges;

var Digraph_map_vertex = G.map_vertex;

var Digraph_iter_edges_e = G.iter_edges_e;

var Digraph_fold_edges_e = G.fold_edges_e;

var Digraph_iter_succ = G.iter_succ;

var Digraph_iter_pred = G.iter_pred;

var Digraph_fold_succ = G.fold_succ;

var Digraph_fold_pred = G.fold_pred;

var Digraph_iter_succ_e = G.iter_succ_e;

var Digraph_fold_succ_e = G.fold_succ_e;

var Digraph_iter_pred_e = G.iter_pred_e;

var Digraph_fold_pred_e = G.fold_pred_e;

var Digraph_transitive_closure = include$1.transitive_closure;

var Digraph_add_transitive_closure = include$1.add_transitive_closure;

var Digraph_transitive_reduction = include$1.transitive_reduction;

var Digraph_replace_by_transitive_reduction = include$1.replace_by_transitive_reduction;

var Digraph_mirror = include$1.mirror;

var Digraph_complement = include$1.complement;

var Digraph_intersect = include$1.intersect;

var Digraph_union = include$1.union;

var Digraph_Dfs = {
  iter: Dfs.iter,
  prefix: Dfs.prefix,
  postfix: Dfs.postfix,
  fold: Dfs.fold,
  iter_component: Dfs.iter_component,
  prefix_component: Dfs.prefix_component,
  postfix_component: Dfs.postfix_component,
  fold_component: Dfs.fold_component,
  has_cycle: Dfs.has_cycle
};

var Digraph_Rand = {
  graph: Rand.graph,
  labeled: Rand.labeled,
  gnp: Rand.gnp,
  gnp_labeled: Rand.gnp_labeled
};

var Digraph_shortest_path = include.shortest_path;

var Digraph_bellman_ford = BF.find_negative_cycle_from;

var Digraph_Topological = {
  fold: include$2.fold,
  iter: include$2.iter,
  fold_stable: S.fold,
  iter_stable: S.iter
};

var Digraph_spanningtree = include$4.spanningtree;

var Digraph = {
  V: V,
  E: Digraph_E,
  is_directed: is_directed,
  create: Digraph_create,
  clear: Digraph_clear,
  copy: Digraph_copy,
  add_vertex: Digraph_add_vertex,
  remove_vertex: Digraph_remove_vertex,
  add_edge: Digraph_add_edge,
  add_edge_e: Digraph_add_edge_e,
  remove_edge: Digraph_remove_edge,
  remove_edge_e: Digraph_remove_edge_e,
  Mark: Digraph_Mark,
  is_empty: Digraph_is_empty,
  nb_vertex: Digraph_nb_vertex,
  nb_edges: Digraph_nb_edges,
  out_degree: Digraph_out_degree,
  in_degree: Digraph_in_degree,
  mem_vertex: Digraph_mem_vertex,
  mem_edge: Digraph_mem_edge,
  mem_edge_e: Digraph_mem_edge_e,
  find_edge: Digraph_find_edge,
  find_all_edges: Digraph_find_all_edges,
  succ: Digraph_succ,
  pred: Digraph_pred,
  succ_e: Digraph_succ_e,
  pred_e: Digraph_pred_e,
  iter_vertex: iter_vertex,
  iter_edges: Digraph_iter_edges,
  fold_vertex: Digraph_fold_vertex,
  fold_edges: Digraph_fold_edges,
  map_vertex: Digraph_map_vertex,
  iter_edges_e: Digraph_iter_edges_e,
  fold_edges_e: Digraph_fold_edges_e,
  iter_succ: Digraph_iter_succ,
  iter_pred: Digraph_iter_pred,
  fold_succ: Digraph_fold_succ,
  fold_pred: Digraph_fold_pred,
  iter_succ_e: Digraph_iter_succ_e,
  fold_succ_e: Digraph_fold_succ_e,
  iter_pred_e: Digraph_iter_pred_e,
  fold_pred_e: Digraph_fold_pred_e,
  find_vertex: find_vertex,
  transitive_closure: Digraph_transitive_closure,
  add_transitive_closure: Digraph_add_transitive_closure,
  transitive_reduction: Digraph_transitive_reduction,
  replace_by_transitive_reduction: Digraph_replace_by_transitive_reduction,
  mirror: Digraph_mirror,
  complement: Digraph_complement,
  intersect: Digraph_intersect,
  union: Digraph_union,
  Dfs: Digraph_Dfs,
  Bfs: Bfs,
  Marking: Marking,
  Coloring: Coloring,
  Classic: Classic,
  Rand: Digraph_Rand,
  Components: Components,
  shortest_path: Digraph_shortest_path,
  ford_fulkerson: ford_fulkerson,
  goldberg_tarjan: goldberg_tarjan,
  bellman_ford: Digraph_bellman_ford,
  PathCheck: PathCheck,
  Topological: Digraph_Topological,
  Eulerian: Eulerian,
  spanningtree: Digraph_spanningtree,
  dot_output: dot_output,
  display_with_gv: display_with_gv
};

var Graph_E = G$1.E;

var Graph_create = G$1.create;

var Graph_clear = G$1.clear;

var Graph_copy = G$1.copy;

var Graph_add_vertex = G$1.add_vertex;

var Graph_remove_vertex = G$1.remove_vertex;

var Graph_add_edge = G$1.add_edge;

var Graph_add_edge_e = G$1.add_edge_e;

var Graph_remove_edge = G$1.remove_edge;

var Graph_remove_edge_e = G$1.remove_edge_e;

var Graph_Mark = G$1.Mark;

var Graph_is_empty = G$1.is_empty;

var Graph_nb_vertex = G$1.nb_vertex;

var Graph_nb_edges = G$1.nb_edges;

var Graph_out_degree = G$1.out_degree;

var Graph_in_degree = G$1.in_degree;

var Graph_mem_vertex = G$1.mem_vertex;

var Graph_mem_edge = G$1.mem_edge;

var Graph_mem_edge_e = G$1.mem_edge_e;

var Graph_find_edge = G$1.find_edge;

var Graph_find_all_edges = G$1.find_all_edges;

var Graph_succ = G$1.succ;

var Graph_pred = G$1.pred;

var Graph_succ_e = G$1.succ_e;

var Graph_pred_e = G$1.pred_e;

var Graph_iter_edges = G$1.iter_edges;

var Graph_fold_vertex = G$1.fold_vertex;

var Graph_fold_edges = G$1.fold_edges;

var Graph_map_vertex = G$1.map_vertex;

var Graph_iter_edges_e = G$1.iter_edges_e;

var Graph_fold_edges_e = G$1.fold_edges_e;

var Graph_iter_succ = G$1.iter_succ;

var Graph_iter_pred = G$1.iter_pred;

var Graph_fold_succ = G$1.fold_succ;

var Graph_fold_pred = G$1.fold_pred;

var Graph_iter_succ_e = G$1.iter_succ_e;

var Graph_fold_succ_e = G$1.fold_succ_e;

var Graph_iter_pred_e = G$1.iter_pred_e;

var Graph_fold_pred_e = G$1.fold_pred_e;

var Graph_transitive_closure = include$6.transitive_closure;

var Graph_add_transitive_closure = include$6.add_transitive_closure;

var Graph_transitive_reduction = include$6.transitive_reduction;

var Graph_replace_by_transitive_reduction = include$6.replace_by_transitive_reduction;

var Graph_mirror = include$6.mirror;

var Graph_complement = include$6.complement;

var Graph_intersect = include$6.intersect;

var Graph_union = include$6.union;

var Graph_Dfs = {
  iter: Dfs$1.iter,
  prefix: Dfs$1.prefix,
  postfix: Dfs$1.postfix,
  fold: Dfs$1.fold,
  iter_component: Dfs$1.iter_component,
  prefix_component: Dfs$1.prefix_component,
  postfix_component: Dfs$1.postfix_component,
  fold_component: Dfs$1.fold_component,
  has_cycle: Dfs$1.has_cycle
};

var Graph_Rand = {
  graph: Rand$1.graph,
  labeled: Rand$1.labeled,
  gnp: Rand$1.gnp,
  gnp_labeled: Rand$1.gnp_labeled
};

var Graph_shortest_path = include$5.shortest_path;

var Graph_bellman_ford = BF$1.find_negative_cycle_from;

var Graph_Topological = {
  fold: include$7.fold,
  iter: include$7.iter,
  fold_stable: S$1.fold,
  iter_stable: S$1.iter
};

var Graph_spanningtree = include$9.spanningtree;

var Graph = {
  V: V$2,
  E: Graph_E,
  is_directed: is_directed$1,
  create: Graph_create,
  clear: Graph_clear,
  copy: Graph_copy,
  add_vertex: Graph_add_vertex,
  remove_vertex: Graph_remove_vertex,
  add_edge: Graph_add_edge,
  add_edge_e: Graph_add_edge_e,
  remove_edge: Graph_remove_edge,
  remove_edge_e: Graph_remove_edge_e,
  Mark: Graph_Mark,
  is_empty: Graph_is_empty,
  nb_vertex: Graph_nb_vertex,
  nb_edges: Graph_nb_edges,
  out_degree: Graph_out_degree,
  in_degree: Graph_in_degree,
  mem_vertex: Graph_mem_vertex,
  mem_edge: Graph_mem_edge,
  mem_edge_e: Graph_mem_edge_e,
  find_edge: Graph_find_edge,
  find_all_edges: Graph_find_all_edges,
  succ: Graph_succ,
  pred: Graph_pred,
  succ_e: Graph_succ_e,
  pred_e: Graph_pred_e,
  iter_vertex: iter_vertex$2,
  iter_edges: Graph_iter_edges,
  fold_vertex: Graph_fold_vertex,
  fold_edges: Graph_fold_edges,
  map_vertex: Graph_map_vertex,
  iter_edges_e: Graph_iter_edges_e,
  fold_edges_e: Graph_fold_edges_e,
  iter_succ: Graph_iter_succ,
  iter_pred: Graph_iter_pred,
  fold_succ: Graph_fold_succ,
  fold_pred: Graph_fold_pred,
  iter_succ_e: Graph_iter_succ_e,
  fold_succ_e: Graph_fold_succ_e,
  iter_pred_e: Graph_iter_pred_e,
  fold_pred_e: Graph_fold_pred_e,
  find_vertex: find_vertex$1,
  transitive_closure: Graph_transitive_closure,
  add_transitive_closure: Graph_add_transitive_closure,
  transitive_reduction: Graph_transitive_reduction,
  replace_by_transitive_reduction: Graph_replace_by_transitive_reduction,
  mirror: Graph_mirror,
  complement: Graph_complement,
  intersect: Graph_intersect,
  union: Graph_union,
  Dfs: Graph_Dfs,
  Bfs: Bfs$1,
  Marking: Marking$1,
  Coloring: Coloring$1,
  Classic: Classic$1,
  Rand: Graph_Rand,
  Components: Components$1,
  shortest_path: Graph_shortest_path,
  ford_fulkerson: ford_fulkerson$1,
  goldberg_tarjan: goldberg_tarjan$1,
  bellman_ford: Graph_bellman_ford,
  PathCheck: PathCheck$1,
  Topological: Graph_Topological,
  Eulerian: Eulerian$1,
  spanningtree: Graph_spanningtree,
  dot_output: dot_output$1,
  display_with_gv: display_with_gv$1
};

export {
  Digraph ,
  Graph ,
  
}
/* G Not a pure module */
